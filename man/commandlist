N: PIGLET
U: pig
D: execute the Piglet graphical editor under X11
T: {
.SS STARTUP
Piglet is started by typing "pig" in a terminal window.  Piglet then
creates an associated graphical window under X11.  The editor scans
both the graphic window and the original shell window that you used to
start Piglet.  You can either type coordinates, or click them with the
mouse.  Commands may be typed at the shell window prompt: "MAIN>".
Anywhere that Piglet expects a number, you can enter a mathematical
expression instead.  Expressions may use the operators
+,-,*,/,(,), and must be enclosed in surrounding parentheses.  For
example, you can add a rectangle to the current device with the command:
.nf
	ADD R1 (5.3/(4-2)),10 (3*5.3/4),20;
.fi 
When entering points with the mouse, the clicks ALWAYS snap to the
grid, giving a powerful way to enter precise coordinates.  Coordinates
hand typed at the prompt are not snapped to the grid.

All the Piglet built-in commands are case-insensitive and can be
abbreviated to just three letters with one exception.  DISPLAY must be
entered as "DISP" or "disp" to distinguish it from "DIStance". 

Piglet's interactive command environment is also a simple shell.  If you
type the name of any executable that can be found in the $PATH variable,
Piglet will run the program, displaying any output in the Piglet text window.

.SS STARTUP
At startup, Piglet sets several internal environment variables including
$PIG_PATH to reasonable defaults.  Then it overwrites the defaults with
any environment variables inherited from the parent shell.  After that,
Piglet searches the $PIG_PATH for a file named $PIG_RC.  (Unless
overridden, $PIG_RC will be set by default to "pigrc").  If this file is
found in the path, Piglet will read the file for command input. 

Any Piglet command can be placed in the $PIG_RC file.  Macro definitions
and SET commands will be read and added to the environment.  This allows
the $PIG_RC file to have the last say in setting the $PIG_PATH and
$PIG_GEOMETRY variables.  However, at this phase of startup, any EDIt
commands are ignored. 

After reading the $PIG_RC file, all the necessary support files are read
using the $PIG_PATH.  These include the menu and font definition files
and process definition files.  After all support files are read, the X11
graphical window is created using the $PIG_GEOMETRY specification. 

Finally, the $PIG_RC file is read a second time.  The contents are now
executed just as if the user typed them.  Now that the X11 system is
initialized, EDIt commands will be honored.

The following example pigrc file sets the SHOW default to "#E", defines
a three macros, sets the starting window geometry and begins an EDI of
the cell named "PLAN".  Piglet uses the double dollar sign "$$" as a
comment character.  Anything after a comment up to an end-of-line is
discarded by the parser and treated as a single end-of-line character. 

.nf
    $$ 
    $$ example piglet initialization file
    $$

    SET PIG_SHOW_DEFAULT "#E"	$$ make cells editable by default
    DEF wi "WIN :X.5;"		$$ window in macro
    DEF wo "WIN :X2;"		$$ window out macro
    DEF wf "WIN :F;"		$$ window fit macro
    SET PIG_GEOMETRY "700x440+10+30";
    EDI PLAN;
.fi

.SS EDITING
Piglet initially displays a splash screen and sits at the MAIN> prompt
waiting for commands.  Typing "EDI <device>" will either load the named 
device from disk if it exists, or will initialize a new device.  By default,
Piglet locks all devices to prevent accidental modifications.  The SHOW
command controls the visibility and modifiability of individual layers. 
Most casual users will just need to type "SHOW #E;" to make all layers
visible and modifiable. (Hint: "E" stands for "Everything").  From this point
on, any edit command may be used.  When finished, the device may be saved
to disk with "SAVE;".

Piglet can nest edit commands.  If you are editing <device1> and you
decide that you need to create a new module, you can type "EDI
<newdevice>;" without leaving your current edit session.  After you SAVE
and EXIT the nested edit, you will be returned to your original edit in
progress.  You can nest edit commands without limit subject to the constraint
that you cannot simultaneously edit any device more than once. 

.SS NAVIGATION
Piglet makes use of the mouse scroll wheel if it exists.  Scrolling the
mouse zooms in or out of the current x,y location.  By moving the mouse
location while zooming it is possible to quickly zoom into any portion
of a drawing.  Zooming can be used in the middle of an ADD command.  For
example, one can mouse the starting coordinate of a line, zoom across
the design, and then click the next coordinate.   If you prefer not to
use the scroll wheel, Piglet can also zoom by clicking on a point with the
middle button and dragging either right or left to zoom in and out.

Single clicking on any point with the middle button will center the viewport
on the clicked point at the current magnification.  Clicking twice on
any point with the middle button will fit the viewport to the bounding box
of the currently edited cell.

The WINDOW command can be used to adjust the current view.  "WIN :F;"
will fit the device in the window.  "WIN 0,0 10,10;" will set the
viewport so that a rectangle with a lower left coordinate of 0,0 and
upper right of 10,10 is centered and fits as tightly as possible.  Using
the WINDOW command with mouse picks is a good way to zoom into a
specific detail of the current device.  After zooming in to check some
detail, "WIN :Z;" is handy to return to the previous window setting. 

.SS UNDO/REDO
All commands which modify the drawing geometry can be undone with
the UNDO command.  The UNDO depth is limited only by available memory.
Any undone operations can be redone with the REDO command. 
Once the user is satisfied with the state of the drawing, and proceeds 
to modify the geometry further, the REDO buffer is cleared.

.SS AUTOSAVE
As part of the UNDO/REDO machinery, Piglet keeps an autosave file named
"#<cellname>.d" in the directory "./cells".  The autosave file is
updated every time the current cell is changed.  When a cell is finally
SAVed the autosave file is deleted so that the normal "<cellname>.d"
file is the only one remaining.  If Piglet crashes, or is QUIT without
saving, then the autosave file will be found next time the cell is edited. 
Piglet then gives the user the opportunity to recover the unsaved
changes at the next edit:

.nf
    MAIN> edi testcell;
    An autosave file was found that is newer than the device file.
       device file:    ./cells/testcell.d, 2803 bytes, Tue May  4 00:00:47 2010
       autosave file: ./cells/#testcell.d, 2827 bytes, Tue May  4 00:31:58 2010
    read autosave file instead of .d file?: (y/n)? 
.fi

Because all the piglet device files are in human readable format, it is
possible to examine the cells directory at any time and to compare the
contents of any autosave files with the associated .d files, and to
either delete the autosave file or copy it onto the .d file as appropriate. 

.SS COMMAND LINE EDITING
Anything typed at the command line goes into a readline buffer.  
A vi command history binding can be obtained by adding the lines

.ti +4
\fBset editing-mode vi\fR
.ti +4
\fBset keymap vi\fR

to the file "~/.inputrc".  It is possible to bind emacs or a simple
up-arrow/down-arrow command-line editor also.  See the GNU readline(1)
man page for more details about commandline editing. 

.SS OUTPUT

When a drawing is SAVed, Piglet creates a human readable cell definition
file which consist of the same commands which were used to create the device
originally.  Piglet can also create postscript, autoplot and gerber
drawings with the PLOT command.  Screendumps can be created in numerous
formats with the DUMP command.  By default, the compact png format is
used for dumps. 

.SS FILES

Piglet requires several configuration files to start up.  These include
the TEXT and NOTE font definition files, the MENU definition file and
the PROCESS layer definition file.

Unless overridden with Environment Variables (see below) Piglet sequentially 
searches the following directories to find the needed startup files.

.nf
    1) current working directory
    2) directory ".pigrc" under the current working directory
    3) directory ".pigrc" in the users HOME directory
    4) /usr/local/lib/piglet
    5) /usr/lib/piglet
.fi

The TEXT and FONT files are named "TEXTDATA.F" and "NOTEDATA.F"
respectively.  These names can be overidden with ENvironment Variables.
The format for both files is plain ASCII.  The files
start with two integers separated by a comma.  The first gives the
height of each character definition and the second, the width.  The
second line has two more integers separated by a comma.  The first is
either 1 or 0 and indicates if font is proportional (1) or is a fixed
width font (0), and the second number is an integer that gives the fixed
width size of the font.

Each character is then listed in printed form and the glyph is defined
by a set of vector coordinates.  It is assumed that each successive x,y
coordinate pair is connected by a stroke unless the path is broken by
the special coordinate "-128,0".  Each definition is terminated by the
special coordinate "-128,-128" followed by a proportional width spacing
for this character.  Here is an example of the first three definitions
in "NOTEDATA.F" for the characters <exclam>, <plus> and <comma>.

.nf
16,12
1,12
! 5,5 7,5 7,15 5,15 5,5 -128,0 5,3 7,3 7,1 5,1 5,3 -128,-128 12
+  3,7 3,9 5,9 5,11 7,11 7,9 9,9 9,7 7,7 7,5 5,5 5,7 3,7 -128,-128 12
,  5,3 5,5 7,5 7,3 5,1 6,3 5,3 -128,-128 12
...
.fi

Piglet's menu is also defined by a customizable file "MENUDATA_V".  The default
menu is defined as:

.nf
ayyyyy |ADD |R|P|L|N|T|
ayyyyb |SHO |C|E|I|A|O|
ayyggg |GRI |#|^|1|2|3|
aggggg |WIN |+|-|4|5|6|
yyyggg |:F|:V|:Z|7|8|9|
yyyggg |:D|:S|:L|,|0|.|
yyyyy  |:W|:C|:N|:O|:R|
yyaaaa |:X|:Y|:M|X|Y|@|
ggg    |LAY |LEV |LOC |
ggg    |FSI |TSL |    |
gyyy   |SHO #E; |;|!| |
wrgbapy|0|1|2|3|4|5|6 |
ww     |       |      |
aap    |MOV |COP |CHA |
ypy    |IDE |POI |LIS |
ygg    |DISP |DIST |  |
ggg    |DUM |PLO |ARC |
gby    |RET |SPL |INP |
ggb    |ARE |WRA |GRO |
ggr    |STR |SMA |PUR |
rrr    |DEL |EXI |BYE |
ygg    |SAV |    |    |
ygg    |EDI |UND |RED |
.fi

The file consists of fields separated by "|" characters.  The first
field consists of some combination of the characters "wrgbapy" which
denote the colors white, red, green, blue, aqua, purple and yellow. 
There should be as many color designators as remaining fields.  The
subsequent fields on each line will be displayed exactly as shown,
rendered in the corresponding color.  The vertical bars are replaced
with white bounding boxes. 

For example, the last line of the example creates three boxes containing
the text "EDI ", "UND ", and "RED ". The color of the three groups of
text will be yellow, green and green, as specified by the color string
"ygg". 

When using the editor, any mouse pick on the menu boxes injects the menu
text directly into the parse stream.  The menu designer should take care
to leave any necessary spaces after command names so that any combination of
mouse picks results in intelligible commands.   Most of the piglet command
primitives are able to be concatenated without spaces, so that the string
"ADD L1:W20:B " is a legal command fragment.

The layer definition process file is named "PROCDATA.P".  Its format is
also plain ASCII.  It consists of one EQUate command line per layer. 
The following PROCDATA.P file defines the characteristics of the first 9
layers. 

.nf
EQU :C1 :P1 :M0 :B :F0 boundary 0
EQU :C2 :P2 :M1 :D :F2 layer1 1
EQU :C3 :P3 :M2 :D :F2 layer2 2
EQU :C4 :P4 :M3 :D :F2 layer3 3
EQU :C5 :P5 :M4 :S :F0 layer4 4
EQU :C6 :P6 :M5 :S :F0 layer5 5
EQU :C7 :P7 :M6 :I :F0 layer6 6
EQU :C1 :P1 :M0 :I :F0 layer7 7
EQU :C2 :P2 :M1 :I :F0 layer8 8
.fi

The first line, for example, says that layer 0 is named "boundary",
drawn with color 1 (white), plotted with pen 1, and uses line type 0
(solid).  The detail layers (2,3,4) are filled with fill pattern 2 and
the other layers are unfilled.  See the EQUate man page for full details. 

.SS ENVIRONMENT VARIABLES

Piglet inheirits any environment variables exported by the parent shell. 
In addition, new variables can be created as private variables by using
the SET command. 

.SS VARIABLES USED BY PIGLET
.TP
.I PATH "dir1<:dir2><:dir3>..."
The PATH variable is used by the SHELL command to search for UNIX commands.
It is initialized by the calling shell, but can be queried and modified within 
Piglet to customize the search path.  
When entering a new PATH the argument to SET will need to be quoted to
protect the ":" delimiters from being interpreted as Piglet options. 
.TP
.I PIG_PATH "dir1<:dir2><:dir3>..."
The search path used for loading all of Piglet's auxiliary files such as
NOTEDATA, TEXTDATA, MENUDATA, PROCDATA, etc.   
Defaults to "./cells:.:./.pigrc:~/.pigrc:/usr/local/lib/piglet:/usr/lib/piglet"
.TP
.I PIG_RC "filename" ; default is "pigrc"
The name of piglet's startup file for environment variables, macros and other customizations.
.TP
.I PIG_FONT_SIZE "<size>" ; default is "10.0"
The default font size used for both note and text if not otherwise overridden with :F option.
.TP
.I PIG_FONT_SLANT "<degrees>" ; default is "0.0"
The default italic font slant (from -45.0 to +45.0) used for both note and text if
not otherwise overridden with :Z option. 
.TP
.I PIG_GEOMETRY "[=]<width>x<height>{+-}xoffset{+-}yoffset" 
The argument is a standard X11 geometry specification.  The first two numbers specify the
width and height of the piglet window in pixels. The second two numbers must
come as a pair and give the offset of the window from one edge of the display.
Positive xoffsets are measured from the left edge and negative from the right.
Positive yoffsets are measured from the top of the screen and negative from the bottom.
If a width or height is too small to be usable with the current menu, the size will
be increased to a reasonable minimum value.  The geometry specification is useful
for placing the graphics window above the command window so that interactive commands
can be easily seen and edited.
.nf
    Some example geometries:

      PIG_GEOMETRY=500x500+0+0 pig	; a small window in upper left corner
      PIG_GEOMETRY=900x700-0+0 pig	; a wide window in upper right corner
      PIG_GEOMETRY=500x700-0-0 pig	; a tall window in lower right corner
      PIG_GEOMETRY=600x600+0-0 pig	; a medium window in lower left corner
.fi
.TP
.I PIG_GRID "<dx> [<dy> [<dxs> [<dys> [<xorig> [<yorig>]]]]]" 
From one to six floats used to set the grid deltax, deltay, xskip, yskip, and x and y origins.
Any parameters left off will remain set to the default grid specification of "10 10 1 1 0 0".
.TP
.I PIG_GRID_COLOR "<num>" ; default is "3"
Used to set the default grid color when editing new cells.
.TP
.I PIG_SHOW_DEFAULT "<SHO_CMD_OPTIONS>" ; default is not defined
If defined, then the SHOW command will be run with <SHO_CMD_OPTIONS>
as an argument immediately after opening any new drawing.
A casual user may wish to set PIG_SHOW_DEFAULT to "#E" so that
all layers are visible and editable by default.
.TP
.I PIG_MENUDATA_FILE "<filename>" ; default is "MENUDATA_V"
Sets the name used for loading the Menu definition file.
.TP
.I PIG_MENUDATA_FONT "<fontname>" ; default is "10x20"
Sets the preferred X11 font name used for loading the Menu definition file.
.TP
.I PIG_NOTEDATA_FILE "<filename>" ; default is "NOTEDATA.F"
Sets the name used for loading the stroke definition file for NOTEs.
.TP
.I PIG_TEXTDATA_FILE "<filename>" ; default is "TEXTDATA.F"
Sets the name used for loading the stroke definition file for TEXT.
.TP
.I PIG_PROCDATA_FILE "<filename>" ; default is "PROCDATA.P"
Sets the name used for loading the process layer definition.
.TP
.I PIG_SPLASH_REP "<cellname>" ; default is "piglogo"
Sets the name of the cell used for the initial splash screen during startup.
The cell should already exist in PIG_PATH.
.TP
.I PIG_PAPER_SIZE "<papersize>" ; default is "8.5x11.0"
Sets the default postscript paper size.  The argument can either be
an explicit paper size in the form <width>x<length>, or any of the
common names listed in the PLOt command manpage.
.TP
.I PIG_SHPFONT<n> "<shp_font_filename>.shp" ; 
Sets the SHP font file name for position <n>.  Piglet allows loading up to 255
SHP fonts.  The font files should be placed in piglet's search path, typically
/usr/local/lib/piglet.  See ADD_NOTE and ADD_TEXT for how to specify which font
to use.

.SS DEBUGGING

Since Piglet is under active development, it is distributed to run under
the gdb() debugger.  The script "pig" runs pig.bin under gdb().  When
running under gdb() most run-time errors will print out a backtrace of
the stack.  If you would like help fixing a bug, please send a copy of
the dump file (named "pigtrace.<process_id>") to Rick Walker <walker AT
omnisterra DOT com> along with some description of what caused the bug. 

When running pig.bin without the debugger, Piglet traps and ignores
most signals, printing a notification to the terminal: "caught 2:
Interrupt.  Use QUIT command to end program".  However, the special
signal SIGQUIT elicits the message: "caught 3: Quit.  do it again and
I'll die!".  Two SIGQUITs in a row will terminate the program.
}

N: ADD_ARC
U: ADD A<layer> [.<cname>] [@<sname>] [:W<width>] [:R<res>] <xy1> <xy2> [<xy3> ...]  <EOC>
D: Add an arc to the current device
S: complete
T: {
Add an arc.  The coords are starting <xy1>, ending point <xy2>
plus a point on the circumference <xy3>.  After the first two
coords are drawn, a "rubber-banded" arc will be drawn until
the final coordinate terminates the command and draws the arc. 
Multiple arcs can be draw with the same command until an EOC is encounterd.

NOTE: Arcs with width are implemented by drawing a line with width
along the path of the arc.  This means that the finished
arc has an effective outside radius <width>/2.0 larger than drawn. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
line width
.TP
.I <res>
arc resolution angle (in degrees, default = 2 degrees)
}

N: ADD_CIRCLE
U: ADD C<layer> [.<cname>] [@<sname>] [:W<width>] [:R<resolution>] [:Y<yxratio>] <xy1> <xy2>... EOC
D: Add a circle to the current device
S: complete
T: {
Add a circle.  Center point <xy1> and a point on the circumference <xy2>
must be specfied.  After adding the centerpoint, a "rubber-banded"
circle is shown on the screen, creating a circle with a radius
coincident with the current mouse position.  Entering the second point
terminates the command and draws the circle. 

The circle will be solid unless a non-zero width is specified, in which
case it will be hollow with a wall-thickness of <width>. 

NOTE: Circles with width are implemented by drawing a line with width
along the perimeter of the circle.  This means that the finished
circle has an outside dimension <width> larger than drawn. 

The <yxratio> argument creates an ellipse with a specified ratio between
major and minor axes.  In this case, point <xy1> places the center of the
oval, and point <xy2> places the extreme of the major axis.  Since the major
axis follows the second point, the oval can be placed at any arbitrary
rotation or size.  See "ADD_OVAL" for a method of creating ovals based on
foci and radius. 

The ":R<resolution>" option gives the resolution in degrees.  This is
handy for making regular polygons.  For instance "ADD C7 :R72" will
create a perfect pentagon.  The pentagon rotates during rubberband
drawing such that the second point, <xy2>, is always on one of the
vertices.  "ADD C7 :R90" is a way to add a rotated square.  "ADD C7
:R120" adds an equilateral triangle. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
width of line
.TP
.I <resolution>
angle (in degrees) circle resolution (default = 2 degrees)
.TP
.I <yxratio>
y-to-x major/minor ratio for creating ovals  (default = 1)
.TP
.I <xy1>
center of the circle.
.TP
.I <xy2>
a point on the radius, or on the major axis if <yxratio>!=1
}

N: ADD_INSTANCE
U: ADD [I] <device> [.<cname>] [@<sname>] [:M<mirror>] [:R<angle>] [:X<x>] [:Y<yxratio>] [:Z<slant>] <xy>... EOC
U: ADD [I] <device> :S<col>,<row> [.<cname>] [@<sname>] [:M<mirror>] [:R<angle>] [:X<x>] [:Y<yxratio>] [:Z<slant>] <xy1> <xy2> <xy3> EOC
D: Add an instance (sub-cell) to the current device
S: good
T: {
Add a device instance with rotation, scaling, shearing and mirroring. 
<mirror> can take the values "X","Y","XY", "0", or "OFF" for mirroring
about the X axis, Y axis, or both.  <rotation> is the rotation angle in
decimal degrees in the range -180.00 to +180.00 with 0.01 degree
increment.  Multiple devices can be placed with multiple <xy> points. 
EOC (or double click) is required to terminate the command. 

If the :S option is given, then the instance will be stepped to create
an array of <col> x <row> instances.  The <col> columns are spaced evenly
along the line connecting <xy1> and <xy2>, and the <row> rows are
spaced evenly along the line connecting <xy1> and <xy3>.  Because there
are no limitations on the placement of the three points, the resulting
array can be rectangular, sheared and/or rotated.  Only the placement of
the instances are controlled by <xy1> <xy2> and <xy3> points.  The
rotation, mirroring, scaling, and shearing of the individual instances
are controlled independently by the :M,:R,:X,:Y,:Z options as described
above.  If it is desired to simulate a rotated rectangular array, then
the appropriate :R option will have to be calculated based on the
placement of the control points.  Only one device can be placed with 
the :S option and the command terminates after the third required point. 

.SS OPTIONS
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <mirror>
one of "X", "Y", "XY", "0", or "OFF" for mirroring around a specified axis
.TP
.I <rotation>
angle (in degrees) of instance rotation
.TP
.I <x>
scale factor for instance
.TP
.I <yxratio>
y-to-x ratio for creating a "stretched" instance
.TP
.I <slant>
slant angle (degrees) for "shearing" the instance
.TP
.I <col>,<row>
two integers specifying the number of columns and rows
for a stepped instance.  ":S1,1" is equivalent to a 
non-stepped instance.
.TP
.I <xy>
the location of the instance.
.I <xy1> <xy2> <xy3>
coordinates controlling the placement and step spacing
for an instance array.  <xy1> is the location of the 0,0
corner of the array.  There will <row> number of instances
spaced along the line between <xy1> and <xy2>.  There will
be <col> number of rows spaced along the line between
<xy1> and <xy3>.
}

N: ADD_LINE
D: Add a line to the current device
U: ADD L<layer> [.<cname>] [@<sname>] [:B<nsegs>] [:W<width>] [:H height] <xy1> <xy2> [<xy3> ...]  EOC
S: good
T: {
Add a line.  Lines are added with "ADD L<layer_number>".  Coordinates
are added with the left-mouse button.  Double-clicking on the same point
will terminate the current line while still allowing new lines to be
created.  Right-clicking or typing ";" will terminate both the line and
the command. 

Lines by default are zero width.  If the :W<width> option is given, then
the line will be drawn with the specified width.  The coordinates specify
the center of the line and the body of the line extends +/-(width/2) on
either side of the centerline.

The LOCK command may be used to constrain line placement.  When
extending a line using the mouse, the mouse coordinate is modified such
that the angle of each new segment is snapped to the closest multiple of
the LOCK angle, consistent with the current drawing grid.  In practice,
this produces precise angles for 45 and 90 degrees, but may result in
slight angle errors for other settings, especially on coarse grids. 
A lock angle of 0 turns off all restrictions on line placement. 

If the :B<nsegs> option is specified with three or more points,
the line is converted to a Catmull-Rom Spline curve with <nsegs>
smoothed points inserted between each of the originally entered points. 
The curve gets visually smoother with higher number of segments, and
smoothing can be turned off by setting <nsegs> to zero. 

If the :H<height> option is specified, it is assumed that the line being
drawn is a microstrip transmission line of specified width and height over
a ground plane. The corners of the line are mitered to minimize the excess
capacitance at the corner and produce a good approximation to a constant
impedance.  The miter geometry calculation is described in [1],[2] and
depends only on width and height of the line.  The miter geometry is
independent of the dielectric constant of the substrate in the range of
dielectric constant 2.5<=(epsilon)<=25.0.  The generated lines are most
accurate in the range of (width/height)>=0.25.  If it is desired to
eliminate mitering, the <height> can be set to 0.0; The published
reference defines mitres only for exact 90 degree turns, but the
algorithm implemented here produces interpolated miters for any angle
while exactly matching the recommended miters for 0,90 degree bends. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
width of line (default=0) 
.TP
.I <nsegs>
number of interpolated segments inserted between each of the
user-supplied control points (default=0) 
.TP
.I <height>
height of line over ground plane (default=0)

.SS REFERENCES
.I [1] 
R.J.P. Douville and D.S. James, Experimental Characterization of
Microstrip Bends and Their Frequency Dependent Behavior, 1973 IEEE Conference
Digest, October 1973, pp. 24-25.

.I [2]
R.J.P. Douville and D.S. James, Experimental Study of Symmetric Microstrip Bends
and Their Compensation, IEEE Transactions on Microwave Theory and Techniques,
Vol. MTT-26, March 1978, pp. 175-181.
}

N: ADD_NOTE
D: Add a note to the current device
U: ADD N<layer> [.<cname>] [@<sname>] [:F<fontsize>][:J<justification>][:M<mirror>] [:R<rotation>] [:Y<yxratio>] [:Z<slant>] [:N<fontindex>]  "string" <xy> EOC
S: good
T: {

Add a note annotation to the drawing using a zero line-width font. 
This is in contrast to the ADD_TEXT command, "ADD T<layer", which adds a
fillable text font using polygons.

If a :N<fontindex> is given, piglet will instead use the SHX font loaded at
the <fontindex> position rather than the legacy stroke font. 

<Rotation> is in degrees with counterclockwise rotations being positive.
<Slant> is in the range -90.00 to +90.00 degrees
with 0.01 resolution, and specifies how many
degrees the y-axis of the character is slanted with respect to the
x-axis.  The note is scaled to have adequate clearance when packed into
single-spaced lines which are <fontsize> apart.  The <yxratio> is used
to proportionally stretch or shrink the text to fill less horizontal
space.  (Note: this is a change from HP Piglet which keeps width
constant while changing height.  This redefinition is much more natural
for creating narrow typefaces.  <Fontsize> controls height, and
<xyratio> controls width.). 

To prevent accidentally adding multiple copies of a text string,
multiple mouse clicks on the same coordinate are ignored and the message
"suppressing double click" is printed to the console. 

The default origin for a note is the lower left or southwest (SW)
corner.  This can be changed by the :J option to any of 9 different
locations.  This feature is very helpful for aligning labels to various
sides of a component. 

The "string" may contain embedded newlines.  These can be entered by
simply typing a carriage return while still in quotes.  This can be
handy for entering a multi-line block of information. 

The default font is defined in NOTEDATA.F and is easily changed.  New 
fonts can be derived from the Hershey font database.  The format is 
documented in the sourcecode file "readfont.c". 

Since version 0.98, Piglet can parse and display AutoCad .SHP font
files.  If :N<fontindex> is not specified, the default note font is a
zero line-width font.  This is in contrast to the ADD_TEXT command, "ADD
T<layer>", which adds a text annotation using a fillable polygon font. 

If <fontindex> is specified, then one of the loaded autocad SHP fonts
will be used instead.  SHP fonts are loaded by putting the ".shp" font
file in piglet's search path and by setting one of the "PIG_SHPFONT<n>"
environment variables in the ".pigrc" file to the name of the SHP font
for position <n>. 

Up to 255 .SHP font files can be loaded at startup and used for either
NOTE or TEXT by specifying the :N<index> option.  The classic piglet
vector fonts are loaded by default at index -1 for NOTE and index -2 for
TEXT.  Indices 0-255 are reserved for .SHP fonts.  Loading of .SHP files
are controlled by setting the environment variables $PIG_SHPFONT1 through
$PIG_SHPFONT255 in the pigrc file.

Piglet's default distribution provides a large selection of public
domain .SHP fonts fonts in /usr/local/lib/piglet/shpfonts and assigns
a selection of them with the following lines in /usr/local/lib/piglet/pigrc:

.nf
    SET PIG_SHPFONT1 "shpfonts/pan.shp"            $$ optional shp fonts
    SET PIG_SHPFONT2 "shpfonts/opt.shp"
    SET PIG_SHPFONT3 "shpfonts/helvo.shp"
    SET PIG_SHPFONT4 "shpfonts/scripts.shp"
    SET PIG_SHPFONT5 "shpfonts/arctext.shp"
    SET PIG_SHPFONT6 "shpfonts/handlet.shp"
    SET PIG_SHPFONT7 "shpfonts/dim.shp"
    SET PIG_SHPFONT8 "shpfonts/gothicen.shp"
    SET PIG_SHPFONT9 "shpfonts/complex.shp"
    SET PIG_SHPFONT10 "shpfonts/hcomx.shp"
    ...
.fi

The command 'ADD N1 :f10 "hello world" 0,0;' will add the note "hello world"
of 10 grid points height to location 0,0 using the default line font
specified in "NOTEDATA.F".  The same command with the :N<num> option will use
the corresponding SHP font instead.  For instance, the command 'ADD T1 :n4 :f10
"hello world" 0,0;' will use the "scripts.shp" font with the above PIG_SHPFONT4
definition.

If there is no file loaded at the <fontindex> position, piglet will default 
back to using the default legacy fonts for NOTES and TEXT. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <fontsize>
font is scaled to permit single-spaced text at a y-delta of <fontsize>
.TP
.I <justification>
A number or string defining where the origin of the text block is.  The default is 0 which
corresponds to the lower-left, or southwest (SW) corner.  The permissable numeric and text values 
for <justification>, and their resulting location of origin are:
.nf
   numeric  text  location of origin
   -------  ----  ------------------
      0     SW     lower-left
      1     S      lower-center
      2     SE     lower-right  
      3     W      middle-left
      4     C      center
      5     E      middle-right
      6     NW     upper-left
      7     N      upper-center
      8     NE     upper-right
.fi
.TP
.I <mirror>
one of "X", "Y", "XY", "0", or "OFF" for mirroring around a specified axis
.TP
.I <rotation>
angle (in degrees) for note rotation
.TP
.I <yxratio>
y-to-x ratio for creating "stretched" text
.TP
.I <slant>
slant angle (degrees) for creating italic text
.TP
.I "string"
The string to be added as a note component.  Should be in quotes.
.TP
.I <xy>
The location of the note.
}

N: ADD_OVAL
D: Add an oval to the current device (unimplemented)
U: ADD O<layer> [.<cname>] [@<sname>] [:W<width>] [:R<resolution>] <xy1> <xy2> <xy3>... EOC
S: unimplemented (easy)
T: {
Add an oval (or more precisely, an ellipse).  Three points are required. 
The first two are focal points, and the third coordinate is a point on
the circumference.  Like the circle, if no width is given, then the
figure is drawn solid.  With a non-zero width, the oval is drawn with a
wall thickness of specified width, and with a hollow interior.  Another
way to create an ellipse is to use "ADD C :Y<xyratio>", which allows
specification of the ratio between major and minor axes. 
.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
width of line
.TP
.I <resolution>
resolution (in degrees) for oval approximation
}

N: ADD_POLYGON
D: Add a polygon to the current device
U: ADD P<layer> [.<cname>][@<sname>][:W<width>] <xy1> <xy2> <xy3> [<xy4>...] EOC
S: good
T: {
Add a polygon.  If the last vertex is not the same as the
first, then an error message will be given, and the polygon
will be completed for you.  Normally, the polygon is solid,
unless a non-zero width is specified, which results in
a hollow figure with a wall thickness of <width>.
.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width> 
linewidth of polygon (unimplemented)
}

N: ADD_RECTANGLE
D: Add a rectangle to the current device
U: ADD R<layer> [.<cname>] [@<sname>] [:W<width>] <xy1> <xy2> EOC
S: good
T: {
Add a rectangle.  The rectangle will be solid unless a
non-zero width is specified, in which case it will be hollow
with a wall-thickness of <width>.  

NOTE: Rectangles with width are implemented by drawing a line with width
along the perimeter of the rectangle.  This means that the finished
rectangle has an outside dimension <width> larger than drawn. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
width of line
}

N: ADD_TEXT
D: Add text to the current device
U: ADD T<layer> [.<cname>] [@<sname>] [:M<mirror>] [:N<fontindex>] [:J<justification] [:R<rotation>] [:Y<yxratio>] [:Z<slant>] [:F<fontsize>] "string" <xy> EOC
S: good
T: {


Add a text annotation to the drawing using a filled polygon font.  This
is in contrast to the ADD_NOTE command, "ADD N<layer", which adds a note
font using zero-width lines. 

If a :N<fontindex> is given, piglet will instead use the SHX font loaded at
the <fontindex> position rather than the legacy polygon font. 

<Rotation> is in degrees with counterclockwise
rotations being positive.  <Slant> is in the range -90.00 to +90.00
degrees with 0.01 resolution, and specifies how many degrees the y-axis
of the character is slanted with respect to the x-axis.  The text is
scaled to have adequate clearance when packed into single-spaced lines
which are <fontsize> apart.  The <yxratio> is used to proportionally
stretch or shrink the text to fill less horizontal space.  (Note: this
is a change from HP Piglet which keeps width constant while changing
height.  This redefinition is much more natural for creating narrow
typefaces.  <Fontsize> controls height, and <xyratio> controls width). 

The "string" may contain embedded newlines.  These can be entered by
simply typing a carriage return while still in quotes.  This can be
handy for entering a multi-line block of information". 

To prevent accidentally adding multiple copies of a text string,
multiple mouse clicks on the same coordinate are ignored and the message
"suppressing double click" is printed to the console. 

The default origin for text is the lower left or southwest (SW) corner. 
This can be changed by the :J option to any of 9 different locations. 
This feature is very helpful for aligning labels to various sides of a
component. 

The default font is defined in TEXTDATA.F and is easily changed.  New
fonts can be easily derived from the Hershey font database.  The format
is documented in readfont.c. 

Since version 0.98, Piglet can parse and display AutoCad .SHP font
files.  If :N<fontindex> is not specified, the default text font is a
fillable polygon font.  This is in contrast to the ADD_NOTE command, "ADD
N<layer>", which adds a note annotation using a zero-line-width stroke font. 

If <fontindex> is specified, then one of the loaded autocad SHP fonts
will be used instead of the default font.  SHP fonts are loaded by
putting the ".shp" font file in piglet's search path and by setting one
of the "PIG_SHPFONT<n>" environment variables in the ".pigrc" file to
the name of the SHP font for position <n>. 

Up to 255 .SHP font files can be loaded at startup and used for either
NOTE or TEXT by specifying the :N<index> option.  The classic piglet
vector fonts are loaded by default at index -1 for NOTE and index -2 for
TEXT.  Indices 0-255 are reserved for .SHP fonts.  Loading of .SHP files
are controlled by setting the environment variables $PIG_SHPFONT1 through
$PIG_SHPFONT255 in the pigrc file.

Piglet's default distribution provides a large selection of public
domain .SHP fonts fonts in /usr/local/lib/piglet/shpfonts and assigns
a selection of them with the following lines in /usr/local/lib/piglet/pigrc:

.nf
    SET PIG_SHPFONT1 "shpfonts/pan.shp"            $$ optional shp fonts
    SET PIG_SHPFONT2 "shpfonts/opt.shp"
    SET PIG_SHPFONT3 "shpfonts/helvo.shp"
    SET PIG_SHPFONT4 "shpfonts/scripts.shp"
    SET PIG_SHPFONT5 "shpfonts/arctext.shp"
    SET PIG_SHPFONT6 "shpfonts/handlet.shp"
    SET PIG_SHPFONT7 "shpfonts/dim.shp"
    SET PIG_SHPFONT8 "shpfonts/gothicen.shp"
    SET PIG_SHPFONT9 "shpfonts/complex.shp"
    SET PIG_SHPFONT10 "shpfonts/hcomx.shp"
    ...
.fi

The command 'ADD T1 :f10 "hello world" 0,0;' will add the text "hello world"
of 10 grid points height to location 0,0 using the default line font
specified in "TEXTDATA.F".  The same command with the :N<num> option will use
the corresponding SHP font instead.  For instance, the command 'ADD T1 :n4 :f10
"hello world" 0,0;' will use the "scripts.shp" font with the above PIG_SHPFONT4
definition.

If there is no file loaded at the <fontindex> position, piglet will default 
back to using the default legacy fonts for NOTES and TEXT. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <fontsize>
font is scaled to permit single-spaced text at a y-delta of <fontsize>
.TP
.I <justification>
A number or string defining where the origin of the text block is.  The default is 0 which
corresponds to the lower-left, or southwest (SW) corner.  The permissable numeric and text values 
for <justification>, and their resulting location of origin are:
.nf
   numeric  text  location of origin
   -------  ----  ------------------
      0     SW     lower-left
      1     S      lower-center
      2     SE     lower-right  
      3     W      middle-left
      4     C      center
      5     E      middle-right
      6     NW     upper-left
      7     N      upper-center
      8     NE     upper-right
.fi
.TP
.I <mirror>
one of "X", "Y", "XY", "0", or "OFF" for mirroring around a specified axis
.TP
.I <rotation>
angle (in degrees) for text rotation
.TP
.I <yxratio>
y-to-x ratio for creating "stretched" text
.TP
.I <slant>
slant angle (degrees) for creating italic text
.TP
.I "string"
The string to be added as a text component.  Should be in quotes.
.TP
.I <xy>
The location of the text.
}

N: ARChive
D: Create archive file of specified device
U: ARC <eoc>
S: good
T: {
Creates an human-readable ASCII file containing all the commands
needed to reconstruct the current device and any sub-cells.  
The archive file contains definitions of all the sub-cells 
used in the drawing, thereby preserving the hierarchy.
}

N: AREa
D: Compute and display area of selected component
S: complete
U: ARE [<component>[<layer>]] xysel [xysel ...] <EOC>
T: {
Calculates and displays the area of the selected component.  The area of
a circle is that of an ideal circle, not the polygonal approximation. 
The area of notes, text and instances is the area of the bounding box. 

The area of lines with width is computed by multiplying the total line
length by the line width.  This gives an exact result for lines that do
not cross themselves. 

The area given for rectangles and polygons is exact.  

Both the area of each component and the cumulative area of all selected
components is displayed after each pick. 

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
.TP
.I <xysel>
A point to select the component to be measured.
}

N: BACkground
D: Specify a background device for the editor
U: BAC [<cellname>]
S: implemented
T: {

This command allows any device to be used as a background.  The origin
of the background device will be in the same location as the origin of
the device currently being edited.  The device specified as the
background device will display with the same parameters as the current
edit device, but none of its components can be selected for edit
operations.  This is a display only option.  One possible use is to
create special grid devices for custom layouts or forms, without the
form being a part of the device. 

If <cellname> is specified, that particular device is displayed in the
background.  If <cellname> is not specified, no background device will
be displayed.

The use of a background device is completely invisible to all editor
functions.  In particular a WINDOW command with the fit option (:F) will
only fit the edited device, not the (possibly larger) background device.

}

N: BYE
D: Terminate the edit session
U: BYE <EOC>
S: complete
T: {
Quit the editing session.
If the user attempts to QUIt or leave the editor with BYE, a list of all
currently modified devices in memory will be printed warning the user
that the devices have not been properly saved.  If a second BYE or QUIT
is typed, the editor will be killed and all unsaved changes will be
permanently lost.   BYE and QUIT are synonyms.
}

N: CHAnge
D: Change characteristics  of  selected components
U: CHA [<component>[<layer>]] {xysel [<comp_options>|"string"|:L<newlayer>]}... <EOC>
S: working
T: {
Changes characteristics of selected components.  Can be optionally
restricted to specified <component> and <layer>.  In any case, only
components which have been made modifiable by the SHOW command can be
changed. 

An <xysel> point selects and highlights the component to be changed.  A summary
of the current non-default component options is printed to the text window.  The user
can then enter any valid option for the selected component type.  The new option
replaces the old value and the device is redisplayed.  Any number of valid options
may be typed until a new <xysel> is given.

If either a NOTE or TEXT is selected, the associated text will be automatically
placed in the commandline history buffer where it can be easily recalled and edited.
See the GNU readline(3) manual page for details on commandline editing.

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
.TP
.I <xysel>
A point to select the component to be changed.
.TP
.I :L<newlayer>
A new layer number to replace existing layer
.TP
.I <comp_options>
Any option normally allowed for the selected component type.
.TP
.I "\'"'string\'"'"
A new string for NOTE and TEXT components
}

N: COPy
D: Copy  a  component  from  one  location to another
U: COP [<component>[<layer>]] [[:P] <xysel>] | [:R <xy1> <xy2>] xyref xynewref ... <EOC>
S: complete
T: {
Copies a component in the current device.  Can be optionally restricted
to copy only a specified <component> and <layer>.  In any case, only
components which have been made modifiable by the SHOW command can be
copied.  

Components to be copied can be selected either by point or by region. 
The default mode is select by point.  However, if you change to select
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple moves of the same type
without re-entering the option. 

When selecting by point, an <xysel> selects and highlights the component
to be copied.  A bounding box is displayed after the <xyref> reference
point is given.  The box tracks the mouse until the final location of
the reference point is given by <xynewref>.  Multiple copies can be
placed by simply entering more coordinates before terminating the
command. 

The :R options allows selection by region.  A bounding box is selected
with <xy1> and <xy2>.  A rubberband rectangle will be displayed once
<xy1> is entered.  When <xy2> is entered, the box is remembered, but
erased.  When the <xyref> reference point is given, the bounding box is
redisplayed.  The box tracks the mouse until the final location of the
reference point is given by <xynewref>.  All components lying completely
within the bounding box will be selected.

Double clicking on <xyref> will terminate the current copy allowing the
selection and copying of a new component. 

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
Layer number, "0" or omitted designates all layers.
.TP
.I <xysel>
A point to select the component to be copied.
.TP
.I <xyref>
A reference point on the component.
.TP
.I <xynewref>
The location for the reference point of the new copy.
.TP
.I :P
Copy by Point (default).  Copy the single component closest to <xysel>. 
.TP
.I :R 
Copy by Region.  Identify zero or more components whose bounding boxes
are entirely contained within the rectangular region defined by <xy1> &
<xy2>.   When selecting by region, a rubber-banded rectangle will be drawn 
after the first coordinate to help the user define the region.
}


N: DATe
D: Print the current date and time to the console
S: complete
U: DAT 
T: {
Prints the current date and time to the console in the format:
"Month/Day/Year Hour:Minutes:Seconds" using 24-hour format.
}

N: DEFine
D: Define a macro
S: implemented (with no arguments)
U: DEF [<macro_name> ["<macro definition string>"]];
T: {
Defines or prints out a macro definition.  If no arguments
are given DEFine acts like "SET :M" and prints out all the 
current macros definitions, one per line, each preceeded
by the string "[M]".  If given only one argument, DEFine
will print out the definition of that one macro.  If given
two arguments, DEFine will create a macro named by the first
argument and give it the value of the second argument.

When the parser encounters a white-space delimited
macro name in the input stream, it will replace it with
the definition text.  Most users will want to put their
favorite definitions in the pigrc file.  

.SS EXAMPLE

Here are some example macro definitions from the default
pigrc file:

.nf
    DEF wi "WIN :X.5;"		$$ window in macro
    DEF wo "WIN :X2;"		$$ window out macro
    DEF wf "WIN :F;"		$$ window fit macro
.fi
}

N: DELete
D: Delete a component
S: works
U: DEL [<comp>[<layer>]] [[:P] <xysel>...] [:R <xy1> <xy2>...] <EOC>
T: {
Deletes a component from the current device.  Optionally can be restricted
to only delete a specified <component> and <layer>.  In any case, only
components which have been made modifiable by the SHOW command can be
deleted.  

Components to be deleted can be selected either by point or by region. 
The default mode is select by point.  However, if you change to delete
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple deletes of the same type
without re-entering the option. 

When selecting by point, an <xysel> selects and highlights the component
to be moved.

The :R options allows selection by region.  A bounding box is selected
with <xy1> and <xy2>.  A rubberband rectangle will be displayed once
<xy1> is entered.  When <xy2> is entered, all components within the bounding
box matching the [<comp>[<layer>]] restriction will be deleted.
.SS OPTIONS
.TP
.I <comp>
A designator limiting the command to a given component type.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <comp> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
Layer number, "0" or omitted designates all layers.
.TP
.I <xysel>
A point to select the component to be deleted.
.TP
.I <xy1>
First corner of the bounding box for delete by region.
.TP
.I <xy2>
Second corner of the bounding box for delete by region.
}

N: DISPlay
U: DISP [ON|OFF]
D: Turn X11 Display on/off
S: complete
T: {
Turns the display on or off.  If given no argument, the display state
is toggled.
}

N: DISTance
D: Measure the distance between two points
S: complete
U: DIS {<xy1> <xy2>} ... EOC
T: {

After entering the first point <xy1> a rubber-banded right-angled
triangle is animated on the screen between <xy1> and the current mouse
location.  The coordinates of both points and the delta_x, delta_y,
and total distance is displayed.

After entering the final point <xy2> a summary is printed to the screen of the
form:

.nf
   xy1=(-600,1100) xy2=(2800,3900) dx=3400, dy=2800, dxy=4404.54 theta=39.4725 (deg.)
.fi

giving the location of each coordinate, the delta_x, delta_y,  delta_xy and the
angle of the line xy1:xy2 with respect to horizontal in degrees.

Pairs of points may be entered indefinitely until receipt of a final EOC or
the entry of another command name.
}

N: DUMp
D: Dump the graphics window to a file
S: PPM file only
U: DUM [:F][:R][:T{bmp|gif|jpg|png|pgm|ppm|xbm}] <plotname> <EOC>
T: {
The DUMP command creates a dump of the current graphic window in the
file "./<plotname>.<suffix>".  If <plotname> is not specified, the name
of the current cell will be used instead.  DUMP internally creates a raw
netpbm (http://netpbm.sourceforge.net/) ppm-formatted image file, but is
able to call external netpbm routines to convert the output to several
other popular formats.  The format can be changed with the :T option to
be one of: .bmp, .gif, .jpg, .pgm, .png, .ppm or .xbm.  The default
format is .png. 

For most purposes, the .png format produces the smallest file size. 
Dumping the demo file "PLAN" resulted in a 1-megabyte .ppm, a 60k .jpg, a
10k .gif, and a 5kbyte .png file.  PNG provided a 200:1 compression over
the raw PPM file! 

Remember that Piglet's command-line options do not allow blank space, so 
":Tgif" works, while ":T gif" is an error.

The :R option swaps black and white pixels saving lots of black ink for
dumps that will be printed out on paper. 

.SS IMPLEMENTATION DETAILS
Other image-file types can be easily added to the source code of the
com_dump() routine if a suitable conversion program can be found.

.SS OPTIONS
.TP
.I :F
Fit the device before dumping the window.  After the dump, the previous window
settings are restored.
.TP
.I :R
Reverse video: swap black and white pixels in the dumpfile to save ink.
.TP
.I :T<image_type>
Select various output image formats using one of 
.nf
    :Tbmp       Microsoft Windows or OS/2 Bitmap format
    :Tgif       Graphics Interchange format
    :Tjpg       Joint Photographic Experts Group format
    :Tpgm       Portable Grey Map format
    :Tpng       Portable Net Graphics format
    :Tppm       Portable Pix Map format
    :Txbm       X11 windows bitmap format
.fi
}

N: ECHo
D: Echo all arguments up to the next EOC to screen
U: ECH [<arg1>[<arg2>]...] <EOC>
S: basic functionality
T: {
Echo will print all of its arguments up to the next <EOC> to the screen. 
<EOC> can be either a newline or a semicolon.  It is a handy way to get
output from a Piglet script, or to read the value of a shell variable. 
For example, "ECHO $PATH" will print out the value of the current PATH
environment variable.  
}

N: EDIt
D: Edit a new or old device
U: EDI <device> 
S: good (no edit in place yet)
T: {
Edit a new or old device.  If the <device> argument is given, a
nested edit is performed.  The current device is pushed onto a stack
and the newly specified device becomes the currently edited cell.  When
an edit is terminated with an EXIT, the stack is popped and Piglet
returns to editing the previous device.  There is no limit to the number
of edits that can be stacked, except for the the constraint that no
individual cell may appear more than once in the edit stack.

If the newly specified device is already in memory, the user will
be asked:
.nf
    "Cell already in memory, read in a new copy?: (y/n)?"
.fi
If "y" is typed, the memory copy will be discarded and a new
copy read in from disk.  If "n" is typed, the old memory copy
will be used, continuing the edit from where it was last EXIted.

If the device is not already in memory, a search will be made
for a definition of the device on disk.  If found, the disk definition
will be read into memory and used.  If the device is neither in memory
nor on disk, a new empty device will be created with the name <device>. 

If a previously defined version of the device is found, the grid, grid
color, lock angle, level and window settings will all be returned to their
last settings.  This information is persistent, and is stored on disk in
the ".d" file whenever a device is SAVed. 

Piglet keeps track of the modification state of every device in memory. 
If a user attempts to EXIt a modified device, the EXIt is aborted and a
warning is printed suggesting that the device should be saved before
exiting.  Typing EXIt twice in a row will force an exit leaving the
device in memory, but with the modification bit still set.  The user may
return to editing the device at any time.  If the user attempts to leave
the editor with QUIT or BYE, a list of all currently modified devices in
memory will be printed warning the user that the devices have not been
properly saved.  If a second QUIT or BYE is typed, the editor will be
killed and all unsaved changes will be permanently lost.  

}

N: EQUate
D: Assign pen/line type to a mask layer
U: EQU [:C<color>] [:P<pen>] [:M{S|D|B|[0-6]}] [:F<fill>] [:B|:D|:S|:I] [<label>] <layer>
S: complete
T: {

Associate a mask layer with a color, fill pattern, plotting pen, and a
mnemonic description of its use.  All layers are initally set to detail,
solid green, unfilled, and not plotted. 

The EQU command allows these settings to be customized for a particular
application or IC process.   Normally, EQUate commands are stored in the
file PROCDATA.P and are read in automatically by Piglet on startup.

EQUate commands may only be entered, LISted, and SAVed in the PROCESS subsystem.

.SS EXAMPLE

Here are a few lines from a typical PROCDATA.P file:


.nf
EQU :C7 :P7 :M0 :D :F0 boundary  0
EQU :C1 :P1 :M0 :D :F0 layer1  1
EQU :C2 :P2 :M1 :D :F0 layer2  2
EQU :C3 :P3 :M1 :D :F0 layer3  3
EQU :C4 :P4 :M2 :D :F1 layer4  4
EQU :C5 :P5 :M2 :D :F1 layer5  5
EQU :C6 :P6 :M3 :D :F2 layer6  6
EQU :C7 :P7 :M3 :D :F2 layer7  7
EQU :C8 :P1 :M4 :D :F2 layer8  8
EQU :C9 :P2 :M4 :D :F2 layer9  9
.fi

The first line, for example, says that layer 0 is named "boundary",
drawn with color 7 (white), plotted with pen 7, filled with pattern 0
(unfilled) and uses line type 0 (solid). 

.SS OPTIONS
.TP
.I <color>
an integer from 0-9 or one of the characters "WRGBCMWYLD" signifying 
white, red, green, blue, cyan, magenta, yellow, white, light grey and dark grey.
.TP
.I <pen>
an integer from 1-7 to specify a plot pen, or 0 to suppress plotting.
Piglet parses this option, and stores it, but pen-based plotting is not
currently implemented.
.TP
.I :M{S|D|B|[0-6]}
Specify the way in which the mask layer is displayed.  S gives solid
lines, D gives dotted lines, and B gives broken (dashed lines).  Line
types can also be designated by numbers.  0-2 are synonymous with S,D,B. 
3 gives "dot-dash", 4 gives "long-short", 5 gives "large-broken", 6
gives "small-broken". 
.TP
.I :F<fill>
Specify the fill pattern for polygons, rectangles, circles and lines, arcs with
width.  0 gives an unfilled outline drawing. 1 gives a solid fill.  Since
Piglet draws by overwriting on the display, two overlapping solid fill patterns
will cause the lower pattern to be obscured.  Fill patterns 2-7 are stipple
patterns designed to have minimal pixel overlap and will allow overlapped
geometries to be visible.  ":F2" gives a 45 degree rising crosshatch.  ":F3"
gives a 45 degree falling crosshatch.  ":F4" gives a diagonal dot pattern.
":F5" gives a rectilinear grid-like dot pattern.  ":F6" gives a brick-like
set of staggered short horizontal lines.  ":F7" gives random dot stipples.
Each family of stipples consists of a set of 10 different phase shifts
corresponding to each pen color.  This prevents stipples of the same pattern,
but different colors from obscuring each other.
.TP
.I :B|:D|:S|:I
Specify the function of the mask layer. B is Boundary, D is Detail, 
S is Symbolic and I is Interconnect.  Detail is normally used for the
actual geometries that are necessary to construct a given device.  Symbolic
layers are used to replace the details of a device with a more
comprehensible symbol.  If the symbolic layers are superimposed on the more
complex detail layers, the designer can use the :N,:D and :S options of the
WINDOW command to show only the symbolic or detailed form of the device.
A properly constructed symbol can allow a circuit to be displayed as
device geometries, schematics, or block diagrams.  Interconnect layers
are used for circuit wiring.  In a detailed display, lines are shown in
their true width, but in a symbolic display they are shown with zero
width (not yet implemented). 
.TP
.I <label>
The <label> associates a short mnemonic name with the mask which will be printed
when components are IDEntified.
.TP
.I <layer>
An integer from 0 to MAX_LAYER (defined in db.h, default is 1024) which
specifies which layer is being modified. 
}

N: EXIt
D: Exit from an EDIT, PROCESS, or SEARCH subsystem
S: complete
U: EXI <EOC>
T: {
EXIT from an EDIT.  Piglet keeps track of the modification state of
every device in memory.  If a user attempts to EXIt from a modified
device which has not been saved, the EXIt is aborted and a warning is
printed suggesting that the device should be saved before exiting. 
Typing EXIt twice in a row will force an exit leaving the device in
memory but with the modification bit still set.  The user may return to
editing the device at any time. 

If the user then attempts to leave the editor with QUIT or BYE, a list
of all modified devices in memory will be printed warning the user that
the devices have not been properly saved.  If a second BYE or QUIT is
typed, the editor will be killed and all unsaved changes will be
permanently lost. 

Piglet allows nested editing of cells.  If a second EDIT command is
given before saving the current device, then the current device is
pushed onto a stack and the newly specified device becomes the currently
edited cell.  When such an edit is terminated with an EXIT, the stack is
popped and Piglet returns to editing the previous device.  There is no
limit to the number of edits that can be stacked, except for the the
constraint that no individual cell may appear more than once in the edit
stack. 

}

N: FILes
D: Purge named files
S: complete
U: $FILES <cellname1> <cellname2> .... <EOC>
T: {
$FILES is the first command in an archive files.  It removes all
listed cells from memory.  The cell names are ordered hierarchically from top 
to bottom such that no deletion leaves dangling references for the remaining cells.
The cells are then redefined in the archive in reverse order, from bottom to top so
that there are no forward references. 
}

N: FSIze
D: Set the default font size for text and notes
S: complete
U: FSI [<fontsize>]
T: {
Set the font size for text and notes.

The default font size is 10.0 when the editor is started, but can be changed
with the FSIze command and will be used for any ADD NOTE or ADD TEXT
command that does explicitly specify a font size with the <:f> option. 

Text and Notes entered with the new default will be saved to disk with
the :F<fontsize> option. 

The current <fontsize> can be printed by running FSize without an argument.

.SS OPTIONS
.TP
.I <fontsize>
Size of font.  The total height of all characters in the font is scaled to be approximately
equal to <fontsize>.  Must be a positive floating point number.

}

N: GRId
D: Set grid spacing or turn grid on/off
U: GRI [ON|OFF] [:C<color>] <delta> <skip> [<xorig> <yorig>]]
U: GRI [ON|OFF] [:C<color>] <xdelta> <ydelta> <xskip> <yskip> <xorig> <yorig>
S: complete
T: {
Modify the grid.  If no arguments, will toggle the visibility of
the grid.  The visibility can be explicitly set with "GRI ON" and "GRI
OFF".  The grid color is set with ":C<color>", where <color> is an
integer from 0-7 signifying the colors "white, red, green, blue, cyan,
magenta, yellow". 

Grid takes either 2,4 or 6 numeric arguments.  With two arguments the
grid <delta> and <skip> are set.  "GRI 10 2" forces all mouse picks to
be multiples of 10 units and will display every other grid tick:
0,20,40, etc.  With four arguments the grid can be offset with an origin
of <xorig>,<yorig>.  "GRID 10 1 5 7" displays grid snap points at ...-5,
5,15,25...  in the x direction and ...-3, 7,17,27...  in the y
direction, With 6 arguments the <delta> and <skip> can be set
independently for both x and y axis, creating a non-isotropic grid. 
This can be useful when designing an IC in which metals with different
widths are used for routing signals in x and y directions. 

When entering points with the mouse, the clicks ALWAYS snap to the grid,
giving a powerful way to enter precise coordinates.

.SS OPTIONS
.TP
.I <color>
an integer from 1-7 signifying white, red, green, blue, cyan, magenta or yellow
.TP
.I <delta>
grid spacing for both x,y axes
.TP
.I <skip>
how many snap points to skip for each displayed point
.TP
.I <xorig>
x origin of the grid (default = 0)
.TP
.I <yorig>
y origin of the grid (default = 0)
.TP
.I <xdelta>
grid spacing for x axis
.TP
.I <ydelta>
grid spacing for y axis
.TP
.I <xskip>
grid skip for x axis
.TP
.I <yskip>
grid skip for y axis

.SS DIAGNOSTICS
The grid normally shows intermediate tick marks between major grid
points.  These extra points are suppressed if the spacing goes below 3
pixels per tick.  If the drawing is zoomed further, such that the major
grid ticks would also be displayed with less than 3 pixels per tick, the
entire grid is suppressed, and an error message is printed to the
console.  The grid is still considered to be on even if a "grid
suppressed" message is printed

.SS FILES
The current grid setting and color is saved with the device on disk.
}

N: GROup
D: Create  a  new  device  from  existing components
S: unimplemented

N: HELp
D: Print out quick summary of command
U: HELP [<commandname>] EOC
S: good
T: {
With no arguments prints a list of all commands to the screen.  With <commandname> prints
a short usage summary of the command.  
}

N: IDEntify
D: Identify named instances or components
U: IDE [<comp>[<layer>]][[:P] <xypnt>] | [:R <xy1> <xy2>] ... EOC
S: good
T: {
The IDEntify command highlights and prints out details of selected
components.  Components can be selected either by point or by region. 
The default mode is select by point.  However, if you change to select
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple selections of the same type
without re-entering the option. 
.SS OPTIONS
.TP
.I :R 
Select by Region.  Identify zero or more components whose bounding boxes
are entirely contained within the rectangular region defined by <xy1> &
<xy2>.   When selecting by region, a rubber-banded rectangle will be drawn 
after the first coordinate to help the user define the region.
.TP
.I :P
Select by Point.  Identify the single component closest to <xypnt>. 
.TP
.I <comp>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
}

N: INPut
D: Take command input from a file
S: complete
U: INP <filename> <EOC>
T: {
Looks for a file <filename> in the current directory and reads the commands into Piglet.
}

N: INTerrupt
D: Interrupt  an  ADD  to  issue another command
S: unimplemented

N: LAYer
D: Set the default layer number
U: LAYER [<layer_number>] <EOC>
S: complete
T: {
Change the default layer.
The default layer is zero when the editor is started, but can be changed
with the LAYER command and will be used for any ADD
command that does explicitly specify a layer. 

For example, if the default layer is set to 3 with the command
.ti +4
\fB>LAYER 3;\fR

then performing 
.ti +4
\fB>ADD C 0,0 0,10;\fR

will add a circle on layer 3.
}

N: LEVel
D: Set the logical level of the current device
S: complete
U: LEV <logical_level> <EOC>
T: {
Sets the logical level associated with the current device.  This can be used to selectively
display components using the "WIN :L<level>" command.
}

N: LISt
D: List information about the current environment
S: complete
U: LIS <EOC>
T: {
If in the EDIT subsystem, the LISt command prints out information about the
current device.  Lists the components in the current device including
type, bounding box and options associated with each device.  Lists the
grid, lock and level settings.  Lists whether the current device is
modified. 

If in the PROCESS subsystem, the LISt command prints out the current 
Process file EQUates.
}

N: LOCk
D: Set the default lock angle for a given device
S: complete
U: LOCK <angle>
T: {
Set the lock angle, in degrees, for constraining line segments.  The default
angle is 0.0 which turns off all constraints.  Invoking LOCK without any
arguments prints out the current <angle> setting.

When extending a line using the mouse, the mouse coordinate is modified
such that the angle of each new segment is snapped to the closest
multiple of the LOCK angle, consistent with the current drawing grid. 
In practice, this produces precise angles for 45 and 90 degrees, but may
result in slight angle errors for other settings, especially on coarse
grids. 

This command sets a variable stored with the current device.  The lock
angle is stored in the device definition file, so is persistent across
edits. 
.SS OPTIONS
.TP
.I <angle>
The lock angle in degrees between 0 and 90.  If a floating point number is
given, the resolution will be rounded to the nearest 0.01 degrees.
}

N: MACro
D: Enter the MACRO definition subsystem
S: unimplemented (hard)

N: MENu
D: Change or save the current menu
S: partial
T: {
Piglet's menu is defined by a customizable file "./MENUDATA_V".  The default
menu is defined as:

.nf
ayyyyy|ADD |R|P|L|N|T|
ayyygg|SHO |C|A|I|+|-|
ayyggg|GRI |#|^|1|2|3|
ayyggg|WIN |;|!|4|5|6|
yyyggg|:F|:V|:Z|7|8|9|
yyyggg|:D|:S|:V|,|0|.|
yyyyyy|:W|:M|:N|:O|:R|
yyaaaw|:X|:Y|X|Y|@|XY|
ww    |      |       |
aaa   |WRA |SMA |GRO |
aaa   |MOV |COP |STR |
ypy   |IDE |POI |LIS |
ygg   |DIST |DISP |  |
ggg   |DUM |PLO |LOC |
ggy   |ARC |RET |INP |
gw    |CHA |         |
rrr   |UND |BYE |DEL |
yyr   |SAV |EDI |EXI |
.fi

The file consists of fields separated by "|" characters.  The first field consists of
some combination of the characters "wrgbapy" which denote the colors white, red, green,
blue, aqua, purple and yellow.  There should be as many color designators as remaining
fields.  The subsequent fields on each line will be displayed exactly as shown, rendered
in the corresponding color.  The vertical bars are replaced with white bounding boxes.

When using the editor, any mouse picks on the menu boxes inject the menu text directly
into the parse stream.  The menu designer should take care to leave extra spaces after
command names so that any combination of mouse picks results in intellegible commands.
}


N: MOVe
D: Move a component from one location to another
U: MOV [<component>[<layer>]] { [[:P] <xysel>] | [:R <xy1> <xy2>] xyref xynewref } ... <EOC>
S: complete
T: {
MOves a component in the current device.  Can be optionally restricted
to move only a specified <component> and <layer>.  In any case, only
components which have been made modifiable by the SHOW command can be
moved.  

Components to be moved can be selected either by point or by region. 
The default mode is select by point.  However, if you change to select
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple moves of the same type
without re-entering the option. 

When selecting by point, an <xysel> selects and highlights the component
to be moved.  A bounding box is displayed after the <xyref> reference
point is given.  The box tracks the mouse until the final location of
the reference point is given by <xynewref>.  Either a double click on
<xynewwref> or an EOC will finalize the move.  Until finalized, multiple
<xynewref> points can be given to fine tune the placement.  EOC does not
terminate the command, but will still allow for further MOVes to be made.

The :R options allows selection by region.  A bounding box is selected
with <xy1> and <xy2>.  A rubberband rectangle will be displayed once
<xy1> is entered.  When <xy2> is entered, the box is remembered, but
erased.  When the <xyref> reference point is given, the bounding box is
redisplayed.  The box tracks the mouse until the final location of the
reference point is given by <xynewref>. 

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
.TP
.I <xysel>
A point to select the component to be moved.
.TP
.I <xyref>
A reference point on the component.
.TP
.I <xynewref>
The new location for the reference point after the move.
.TP
.I :P
Move by Point (default).  Move the single component closest to <xysel>. 
.TP
.I :R 
Move by Region.  Identify zero or more components whose bounding boxes
are entirely contained within the rectangular region defined by <xy1> &
<xy2>.   When selecting by region, a rubber-banded rectangle will be drawn 
after the first coordinate to help the user define the region.
}

N: PLOt
D: Make a plot of the current device in various formats
S: letter size only
U: PLO [:F] [:B] [:G] [:L<linewidth>][:TA|:TD|:TG|:TP|:TS] [:P<papersize>] <plotname> <EOC>
T: {
The PLOT command creates a plot of the current window in the
file "./<plotname>.<suffix>.  If the <plotname> is not specified, the
name of the cell will be used instead.  Unless changed with the :T
option, the default output is postscript and the suffix is ".ps".  The
postscript file will be plotted for printing on the paper size specified
with the :P option, and will be printed as either landscape or portrait
depending on the shape of the drawing.  Piglet fits the entire displayed
window to the postscript output.  If the size of the printed image is
too small, it may be advantagious to resize the X11 display window to
fit the cell more closely. 

The :P<pagesize> option will take either several common pagesize names
or an explicit page size in inches.  Pagesize names include: A0, A1, A2,
A3, A4, A5, A6, A7, A8, A, ANSIA, ANSIB, ANSIC, ANSID, ANSIE, ANSIF,
ARCHA, ARCHB, ARCHC, ARCHD, ARCHE, atlas, B0, B1, B2, B3, B4, B4, B6,
B7, B8, B9, B, brief, C, crown, C5envelope, comm10envelope, D, demy,
delenvelope, E, elephant, executive, folio, foolscap, index, ISOA0,
ISOA1, ISOA2, ISOA3, ISOA4, ISOA5, ISOA6, ISOA7, ISOA8, ISOA9, ISOB1,
ISOB2, ISOB3, ISOB4, ISOB5, ISOB6, ISOB7, ISOB8, ISOB9, ledger, legal,
letter, medium, post, royal, and tabloid.  The page sizes are not case
sensitive.

Explicit page sizes use the format :P<width>x<length>.  For example,
printing on legal paper could be done with either "PLO :Plegal;" or with
"PLO :P8.5x14;".

If no papersize is given, the PLOt command will obey the $PIG_PAPER_SIZE 
environment variable which defaults at startup to "8.5x11".  A line
similar to 'SET PIG_PAPER_SIZE "8.5x14"' can be placed in the .pigrc file,
or typed from the command interpreter to make all subsequent plots default
to the new paper size.  Any <papersize> format used for the :P option 
may be used for the $PIG_PAPER_SIZE argument.

If the ":TA" option is used, Piglet will produce a simple file using the
PdPlot line drawing syntax with the suffix ".pd".  The PdPlot file
consists of x,y pairs, one pair per line, interspersed with "jump" and
"pen <pennumber>" commands.  The default is to draw lines connecting
consecutive points unless an intervening jump command temporarily turns
off the drawing function.   PdPlot files should be easy to parse and pass
to other programs for further processing.

If the ":TD" option is used, Piglet will produce a line drawing in a
subset of the DXF format using the suffix ".dxf".  The pen colors are
adjusted to be suitable for direct importation into openoffice.  The DXF
format currently does line drawing only.  The outlines of rectangles
circles and polygons are drawn but not filled. 

If the ":TG" option is used, Piglet will output a pseudo-gerber file
with the suffix ".gb".  The output file is subset of the Gerber RS-274X
syntax with extra comment lines added to call out various layers in the
drawing.  Gerber files typically include only one layer per file. 
Piglet is distributed with an awk script called "gerbsplit".  Running
gerbsplit on the output plot file will create one properly formatted
gerber file per layer, with the name "gerbplot.gb<layernumber>".   These
layers are in a format suitable for sending to a PC board vendor.

PLOT with no arguments will plot just the currently visible portion of
the device.  The ":F" option will fit the window to the device prior to
plotting and restore the existing window settings after the plot.

For postscript blueprints and presentations it is often helpful to
create black and white drawings from an original color drawing.  The
":B" option will plot the figure converting all pen colors to black. 
The ":G" option will convert colors to various shades of grey. 

Depending on the resolution of the drawing it may be helpful to change
the postscript linewidth using ":L<linewidth>". 

.SS IMPLEMENTATION DETAILS
Currently, the postscript file is not hierarchical and so can be quite
big.  It would be a nice project to define each cell individually and
then instantiate them hierarchically.  The render time would go up, but
the size of the plot file would shrink dramatically for hierarchical
designs. 

.SS OPTIONS
.TP
.I :F
Fit the device before plotting the window.  After the plot, the previous window
settings are restored.
.TP
.I :TA
Plot the current device in PdPlot (Autoplot) format with a ".pd" suffix.
.TP
.I :TD
Plot the current device in DXF format with a ".dxf" suffix.
.TP
.I :TG
Plot the current device in Gerber format with automatic :F fitting with a ".pg" suffix.
.TP
.I :TP
Plot the current device in Postscript format without automatic fitting
using a ".ps" suffix.  Only the geometries visible on the display window
will be plotted.  This is the default plot mode if no :T<plottype> command is
given.  
.I :TS
Plot the current device in scalable vector graphics format 
with automatic fitting using a ".html" suffix. If the .html file
is displayed in a web browser, any top level cells will be
automatically clickable to the link <name>.html.  This allows
piglet to be used for generating hierarchical dynamically linked 
graphical documentation.
.TP
.I :P<pagesize>
Observed for postscript output.  Pagesize can be any number of common
papersize names or an explicit page size given in the form of
<width>x<height> in units of inches. 
.TP
.I :G
Plot postscript in greyscale.
.TP
.I :B
Plot postscript in black pen.
}

N: POInt
D: Display  the  coordinates  of  specified  point  on  the screen
U: POI <xy1>... EOC
S: complete
T: {
The POInt command takes a series of xy points and simply prints their
coordinates to the screen.  No change is made to the database.
You might also notice that Piglet constantly updates a textual
version of your current mouse coordinates in the upper left hand
corner of the graphical window.
}

N: PROcess
D: Enter the PROCESS subsystem
U: PRO EOC
S: implemented
T: {
Entering the process system allows listing of the process file.
Entering PRO, followed by LISt, will list the current set of layer EQUates which define
layer color, pen type, and line types currently in use.
}

N: PURge
D: Purge device definitions from memory and disk
S: complete
U: PUR <cellname>
T: {
Removes the cell definition from memory, and optionally from harddisk. 
If the command is typed during interactive usage, the user is asked
permission for removing the disk file.  If PURGE is encountered during a
RETRIEVE command, both the disk file and the memory copy are deleted
without asking. 
}

N: QUIt
D: Terminate edit session
S: complete
U: QUI <EOC>
T: {
Quit the editing session.
If the user attempts to QUIt or leave the editor with BYE, a list of all
currently modified devices in memory will be printed warning the user
that the devices have not been properly saved.  If a second BYE or QUIT
is typed, the editor will be killed and all unsaved changes will be
permanently lost.   BYE and QUIT are synonyms.
}

N: REDo
D: REDo the last command
U: RED <EOC>
S: complete
T: {
Reapplies any change to the current cell reversed by the UNDo command.

Piglet makes a copy of the entire device definition list before any 
change and pushes it on an undo stack associated with each device.
The depth of the stack is only limited by available memory.

When an UNDo is performed, the state prior to the UNDo is pushed on
the REDo stack.  UNDo and REDo can be performed in any order up
to the limits of the saved information.  

When the user finally makes a change to the cell
with the any of the ADD, CHAnge, COPy, DELete, MOVe, SMAsh, STRetch,
or WRAp commands, the contents of the REDo stack are
cleared.

The information in both the UNDo and REDo stacks is
lost when the editor is exited.

REDo prints the depth of both the UNDO and REDo stacks.
}

N: RETrieve
D: read commands from an ARCHIVE file
S: complete
U: RET <archivefile>
T: {
Looks for a file at "./cells/<archivefile>_I" and reads those commands
into the editor.  A properly formed archive will PURGE all files before
redefining them and will have all hierarchical cell definitions ordered
with no forward references.  This is the case for all Piglet-generated
archives. 

During the retrieve, the display is turned off and all cellnames are
echoed to the display as they are read in. 
}

N: SAVe
D: Save the current file or device to disk
S: complete
U: SAVE <newname>
T: {
Saves the current drawing to a file.  Currently files are saved in the
directory "./cells" with the the name and extension of <cellname>.d. 
Later versions of PD Piglet will add a search path to give flexibility
for the directory used.  If <newname> is given, the current cell is
saved (duplicated) to the file "./cells/<newname>.d".  In this case the
current drawing is still marked modified and will cause an error message
if an attempt is made to exit the editor before saving the current
drawing. 

The SAVE file is a human readable transcript of the exact commands that
you typed and moused to create the cell in the first place.  You can
edit this file (carefully) and the textual changes will take effect next
time you start a new Piglet and read in the definition.  The
"<cellname>.d" file contains the definition of the cell <cellname>. 
If <cellname> includes other cells, they will only be called by name in
<cellname>.d and will not be defined unless the program can find the
corresponding ".d" files.  In other words, if you mail a friend a ".d"
file, they will be unable to reconstruct your cell if it has any
hierarchy.  If you want a full, self-contained definition of your work,
then you should use the "ARCHIVE" command which defines every cell
used in a given drawing.

If there have been any NONAME instances created with the WRAP command,
they will be automatically smashed when the device is written to disk.
The wrapped instances will still remain in memory, however, so a given
device may be written multiple times without destroying the temporary
hierarchy created with the wrap command.  When the editor is finally 
closed, all NONAME instances will be permanently lost.

Most commands may be terminated by typing either an EOC or the name of
another command.  SAVE is an exception to this rule.  In the event that
the user accidently types the SAVE command more than once, Piglet will
quietly ignore the extra SAVE commands.  This prevents a command like
"SAVE SAVE <a_new_cellname> EXI" from erroneously saving to the current
cell in addition to <a_new_cellname>.d. 

}

N: SEArch
D: Modify the search path
S: unimplemented (moderate)

N: SET
D: Set or read a Piglet environment variable
U: SET [:P] [:E] [:M]
U: SET [<variable> [<value]] 
D: Set environment variables
S: partial
T: {
Piglet inheirits any environment variables exported by the parent shell.
In addition, new variables can be created as private variables by using the SET command.  
If called with no arguments, SET will print out the list of all currently defined
variables preceeding each one with either [E] for exported variables,
[P] for private variables, or [M] for macro definitions.  The :P, :E and
:M options limit the listing to only private variables, exported
variables, or macro definitions, respectively.  With just one argument,
SET will print the value of the variable named by the argument.  With
two arguments, SET will set the variable named by the first argument to
the value of the second argument. 

If a UNIX command is run by typing its name at the command prompt or as
an argument to the SHELL command, then its enviroment will be initialized
to include all of Piglet's exported variables. 

.SS VARIABLES USED BY PIGLET
.TP
.I PATH "dir1<:dir2><:dir3>..."
The PATH variable is used by the SHELL command to search for UNIX commands.
It is initialized by the calling shell, but can be queried and modified within 
Piglet to customize the search path.  
When entering a new PATH the argument to SET will need to be quoted to
protect the ":" delimiters from being interpreted as Piglet options. 
.TP
.I PIG_PATH "dir1<:dir2><:dir3>..."
The search path used for loading all of Piglet's auxiliary files such as
NOTEDATA, TEXTDATA, MENUDATA, PROCDATA, etc.   
Defaults to "./cells:.:./.pigrc:~/.pigrc:/usr/local/lib/piglet:/usr/lib/piglet"
.TP
.I PIG_FONT_SIZE "<size>" ; default is "10.0"
The default font size used for both note and text if not otherwise overridden with :F option.
.TP
.I PIG_FONT_SLANT "<degrees>" ; default is "0.0"
The default italic font slant (from -45.0 to +45.0) used for both note and text if
not otherwise overridden with :Z option. 
.TP
.I PIG_GRID "<dx> [<dy> [<dxs> [<dys> [<xorig> [<yorig>]]]]]" 
From one to six floats used to set the grid deltax, deltay, xskip, yskip, and x and y origins.
Any parameters left off will remain set to the default grid specification of "10 10 1 1 0 0".
.TP
.I PIG_GRID_COLOR "<num>" ; default is "3"
Used to set the default grid color when editing new cells.
.TP
.I PIG_MENUDATA_FILE "<filename>" ; default is "MENUDATA_V"
Sets the name used for loading the Menu definition file.
.TP
.I PIG_NOTEDATA_FILE "<filename>" ; default is "NOTEDATA.F"
Sets the name used for loading the stroke definition file for NOTEs.
.TP
.I PIG_TEXTDATA_FILE "<filename>" ; default is "TEXTDATA.F"
Sets the name used for loading the stroke definition file for TEXT.
.TP
.I PIG_PROCDATA_FILE "<filename>" ; default is "PROCDATA.P"
Sets the name used for loading the process layer definition.
.TP
.I PIG_SPLASH_REP "<cellname>" ; default is "piglogo"
Sets the name of the cell used for the initial splash screen during startup.
The cell should already exist in PIG_PATH.
.TP
.I PIG_X11MENU_FONT "<X11fontname>" ; default is "10x20"
Sets the name of the X11 font to be used for the menu and on-screen coordinate
annotation.  Piglet will try to load the font named by this environment
variable (if set).  If the name font is not available, Piglet will then
attempt to fallback to "10x20", "9x15" and then "fixed".  The X11
"xlsfonts" command can be used to give you a list of fonts available on
your system. 
.SS EXAMPLES
.TP
.B ksh> PIG_SPLASH_REP=mylogo pig
Change Piglet's splash screen to use mylogo for this run only.
.TP
.B ksh> export PIG_SPLASH_REP=mylogo; pig
Change Piglet's splash screen for all future runs from this shell.
.TP
.B MAIN> SET PIG_GRID "20 20"
Inside Piglet, change the default grid for new cells to be 20 units spacing
in both x and y, leaving skip and offsets unchanged.
.TP
.B MAIN> SET PIG_GRID "10 10 1 1 5 5"
Inside Piglet, change the default grid for new cells to be 10 units spacing
in both x and y, skip of 1 and origin of the grid at 5,5.
.TP
.B MAIN> SET
List all environment variables
.TP
.B MAIN> SET :P
List only Piglet's private environment variables.  (Note, if any of Piglet's
normally private variables have been overridden by the parent shell, then they
will appear as exported variables and must be viewed with the :E option).
}

N: SHEll
D: Run a shell command from within the editor
U: SHELL [command string] <EOL>
S: partial
T: {
Under most conditions, the user will not need to explicitly type the SHELL
command. When you type a command at the text prompt, Piglet searches for 
an internal command of that name.  If it doesn't find one to execute, 
then it looks through the $PATH variable to see if there is a UNIX command
that can be executed.  If so, it spawns a subshell and runs the UNIX command
sending stdout to the terminal.  This is a handy facility for running the UNIX
ls(1) command.

If SHELL is typed with no command string is given, an interactive shell is created.
When the shell is killed, control will return to the Piglet command interpreter.

SHELL uses the $PATH variable to search for UNIX executables.  This
variable is inheirited from the Piglet parent process, but may be
queried and modified using the SET command.  When entering a new PATH
the argument to SET will need to be quoted to protect the ":" delimiters
from being interpreted as Piglet options. 
}

N: SHOw
D: Define which kinds of things to display
U: SHOW {+|-|#}{EACILNOPRT}<layer>
S: complete
T: {
The SHOW command controls what layers are visible and modifiable in the
drawing.  Changes made with the SHOW command only become visible after the
next WINDOW command.

All drawings default to ALL layers visible and ALL layers non-modifiable
when first created or read from disk.  This feature makes it much safer
to browse critical files with Piglet.  No layers are modifiable unless
explicitly unlocked with the SHOW command.  Changes to the SHOW settings
only affect the component currently being edited.  SHOW settings remain
with each component as long as the component is in memory. 

Casual users may grow tired of typing "SHOW #E;" after every "EDIT".  The 
default show setting may be overridden by setting the "PIGLET_SHOW_DEFAULT" 
environment variable.  It can either be set and exported in the UNIX shell, or
set from within Piglet using the SET command.  For example, invoking Piglet from
the UNIX shell with
.nf
	sh> PIGLET_SHOW_DEFAULT="#E" pig
.fi
will cause all cells to be opened modifiable and visible by default.

.SS EXAMPLES
.TP
.B SHO #E;
Make ALL layers visible and modifiable
.TP
.B SHO #E -C7;
Set ALL layers visible and modifiable. except circles on layer 7
.TP
.B SHO -E #R3;
Make nothing editable or visible except rectangles on layer 3 
.TP
.B SHO #E7 +E5; 
Display layers 7 and 5, but only layer 7 is modifiable
.SS OPTIONS
.TP
.I {+|-|#}
One of three modifiers. "+" makes the layer visible, "-" turns off visibility and modifiability, "#" makes
the layer both visible and modifiable.
.TP
.I [EACILN0PRT]
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
}



N: SMAsh
D: Replace an instance with its components
U: SMASH <device_name> [[:P] <xysel>] | [:R <xy1> <xy2>] ... EOC
S: partial
T: {

The SMAsh command will replace a selected instance with copies of the
individual components that define the instance.  

Instances to be smashed can be selected either by point or by region. 
The default mode is select by point.  However, if you change to select
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple smashes of the same type
without re-entering the option. 

When selecting by point, an <xysel> selects and highlights the instance
to be smashed.  The instance closest to <xysel> is selected. 
If <device_name> is given, then only instances of
<device_name> can be selected.  The first <coord> simply highlights the
instance.  The SMAsh is only performed after EOC, which can be a
double-click on the same <coord> or a command terminating semi-colon
(;).  Using a double-click allows multiple SMAshes to be performed with
one command. 

The :R options allows selection by region.  A bounding box is selected
with <xy1> and <xy2>.  A rubberband rectangle will be displayed once
<xy1> is entered.  When <xy2> is entered the bounded instances are smashed.

Instances to be SMAshed can be scaled, mirrored, or rotated.  Instances
that have been sheared with the :Z option or aspected with the :Y option
may not be smashed.  This could lead to distorted geometries which do
not fit on the grid due to round off errors.  

Rectangles rotated by exact multiples of 90 degrees will remain as
rectangles after SMAshing.  Rectangles rotated by non-orthogonal angles
will be smashed into equivalent polygons. 

Smashing should be done with care.  Smashing a instance destroys the
hierarchy of the drawing and can tremendously increase the number of
components in a device. 

.SS OPTIONS
.TP
.I :P
Smash by Point (default).  Smash the single instance closest to <xysel>. 
.TP
.I :R 
Smash by Region.  Smash zero or more instances whose bounding boxes
are entirely contained within the rectangular region defined by <xy1> &
<xy2>.   When selecting by region, a rubber-banded rectangle will be drawn 
after the first coordinate to help the user define the region.

}

N: SPLit
D: Cut a component into two halves
S: unimplemented (moderate)

N: STEp
D: Copy a component in an array fashion
S: unimplemented (moderate)

N: STRetch
D: Move an internal point of a component
S: partial
U: STR [[<component>[<layer>]] {[:P] <xysel> <xyref> <xynewref> } ...
U: STR [[<component>[<layer>]] {:R <xyll> <xyur> <xyref> <xynewref> } ...
T: {

STRetch can move either single vertices or edges of components as selected
by <xysel>, or multiple vertices selected by the bounding box <xyll> <xyur>.
The default mode is to STRetch by point.  To select by region, the ":R" option
can be given.  Once the mode has been switched to region, the :P option can be used
to return to point selection mode.

.SS STRetch by point

STRetch moves either a vertex or an edge of a Rectangle, Line or
Polygon to a new location with respect to a specified reference point. 

STRetch applied to a Circle modifies the point on the circumference of
the circle. 

As a convenience, and because STRetch is commonly used to "tidy up" a
drawing, a STRetch applied to Notes, Text and Instances behaves the same
as the MOVE command. 

The <xysel> point selects the component to be modified.  The <xyref>
point selects the edge or vertex to be modified and acts a reference
point for the move.  Only components matching the optional <component>
and <layer> descriptors will be selected. 

The distance between <xyref> and each of the vertices is tested along
with the distance between <xyref> and the mid-point of each line, polygon or
rectangle segment.  If <xyref> is closer to a vertex, then the delta between
<xyref> and <xynewref> will be added to the vertex.  If <xyref> is
closer to a midpoint, then the delta between <xyref> and <xynewref> will
be added to both the endpoints of the selected segment. 

The placement of <xynewref> is snapped to the nearest grid point such
that the angle between <xyref> and <xynewref> satisfies the current
<lock> angle set by the LOCK command.  This can be used to keep
manhattan geometries precisely orthogonal. 

.SS STRetch by region

When the :R option is given, STRetch will pull all component points
matching the <component> and <layer> descriptors that lie within the
bounding box given by <xyll> and <xyur>.  Any two diagonal corners of
the bounding box may be specified.  After entering <xyll> a
rubber-banded outline will track the mouse to help with the placement of
<xyur>. 

Once the components and nodes have been selected, they are moved by
the vector difference between <xyref> and <xynewref>.  After entering
<xyref> all affected components are drawn in rubber-band mode until 
finally entering <xynewref>.

Components fully enclosed by the bounding box are simply moved.

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
.TP
.I <xysel>
xy-coordinate to select the component to be modified.
.TP
.I <xyll>
xy-coordinate of one corner of the bounding box used to select multiple vertices
.TP
.I <xyur>
xy-coordinate diagonally opposite <xyll> specifying the bounding box used to select multiple vertices
.TP
.I <xyref>
A reference point on the component which selects which vertex or line segment to modify.
.TP
.I <xynewref>
The location for the reference point of the new copy.
}

N: TRAce
D: Highlight named signals
S: unimplemented (easy)

N: TSLant
D: Get or set the default font slant for italic text and notes
S: complete
U: TSL [<slant>] <EOC>
T: {
Set the default font slant for italic text and notes.

The default font slant is zero when the editor is started, but can be changed
with the TSLant command and will be used for any ADD NOTE or ADD TEXT
command that does explicitly specify a slant with the <:z> option.  

Text or Notes added with a non-zero TSLant will be saved with the :z
option set to <slant>. 

The current <slant> value can be printed by running TSLant without an argument.

.SS OPTIONS
.TP
.I <slant>
Angle to slant text and notes.  Limited to +/- 45.0 degrees.
A positive slant leans to the right, approximating an italic font.
}


N: UNDo
D: Undo the last command
U: UND <EOC>
S: complete
T: {
Reverses the last change to the current cell.  UNDO reverses changes
made with the ADD CHAnge COPy DELete MOVe SMAsh STRetch and WRAp
commands.

Piglet makes a copy of the entire device definition list before any 
change and pushes it on an undo stack associated with each device.
The depth of the stack is only limited by available memory.

When an UNDo is performed, the state prior to the UNDo is pushed on
the REDo stack.  UNDo and REDo can be performed in any order up
to the limits of the saved information.  

When the user finally makes a change to the cell
with the any of the ADD, CHAnge, COPy, DELete, MOVe, SMAsh, STRetch,
or WRAp commands, the contents of the REDo stack are
cleared.

The information in both the UNDo and REDo stacks is
lost when the editor is exited.

UNDO prints the depth of both the UNDO and REDo stacks.
}

N: UNIts
D: Set   editor  resolution  
U: UNIts [<unitvalue>] <EOC>
S: partial
T: {
Piglet uses the <unitvalue> to constrain the possible GRID settings.  By
default, <unitvalue> is set to 1000, which forces all user grids to be integer
multiples of 1/1000 of the base unit.  For example, with <unitvalue> set to
100, an attempt to set the GRID to 0.125 would result in an error
message and the grid set to 0.13. 

The <unitvalue> only constrains points entered by grid snapping.  Points explicitly
typed at the commandline are quantized by Piglet's global resolution RES which can
be set at compile time in "db.h" and is typically 5 significant digits.

If UNITs is invoked without any arguments, the current unit setting is printed.

.SS OPTIONS
.TP
.I <unitvalue>
The <unitvalue> is the number of subdivisions that Piglet will allow for a unit grid.
It must be a positive integer less than 10^RES.
A <unitvalue> of 1000 would be suitable for a drawing in inches, with a resolution of 1/1000 of an inch.
}

N: VERsion
D: Identify the version number of program
S: complete

N: WINdow
D: Change the current window parameters
U: WINdow :X[<scale>] [:N<physical>] [:F] [:Z] [:O<layer>] [<xy1> [<xy2>]] <EOC>
S: good
T: {
Window with no arguments simply refreshes the display.  Give only one
<xy1> coordinate the window is re-centered (panned) to the new point. 
With both <xy1> and <xy2> the window is zoomed to the new bounding box. 
If EOC is given by a double click, multiple window commands can be
entered in succession. 

The last window setting used in editing a device is saved along with the
device so that the same editing environment can be restored the next
time the device is edited.

If you have a drawing complex hierarchy, you can simplify the view by
using the ":N<nest_level>" of the WIN command.  "WIN :N0" will show all
sub-cells as bounding boxes.  "WIN :N1" will show all sub-cells of
sub-cells as bounding boxes, and so on. 

Piglet normally will draw polygons as specified in the PROCESS file.  If
a layer is difficult to see, it can be toggled into solid fill mode by
using "WIN :O<layer>"; The filled state is sticky and will remain
throughout the edit session, but will not be saved when Piglet is
exited.  Repeating the command will toggle the layer fill back to the
original state.  "WIN :O;" with no argument will toggle all layers from
solid fill to their normal PROCESS fill definitions. 

.SS OPTIONS
.TP
.I :O<layer>
Toggle between solid fill and PROCESS-defined fill on one or more layers.  
If the <layer> argument is provided, only the specified layer fill will be toggled.
If <layer> is omitted, then all layers will be toggled.
.TP
.I :X<scale>
Factor by which to scale the current window.  Limited to range 
of 0.01 ... 100.0.
.TP
.I :F
Specify fitting the window to the bounding box of the current device
.TP
.I :N<physical>
Only display nesting down to <physical> number of hierarchy levels (default=9)
.TP
.I :Z 
Toggles window to previous settings.
}

N: WRAp
D: Create  a  new  device  using  existing components
S: complete
U: WRAP [<component>[<layer>]] [<devicename>] <xyorig> <xy1> <xy2> EOC
T: {
Creates a new device out of the selected components.  Selection is done
by taking all the components completely enclosed by the rectangular
region defined by <xy1> and <xy2>.  Components can be further restricted by
the optional <component><layer> argument. Partially enclosed components are
omitted from the new device definition.  Once selected, the group of
components is replaced by an instance named <devicename> of the newly
created device definition.  The <devicename> is automatically saved to disk
when it is created.  It is an error for <devicename> to exist either in
memory or on disk prior to the WRAp command. 

WRAp is commonly used to MOVe or COPy various sub-regions of a drawing. 
For this purpose, <devicename> can be omitted, and a unique name of the
form "NONAME_<number>" will be automatically generated.  Such components
can be subsequently MOVed or COPied and will be automatically smashed
onto the disc when the current device is saved.  NONAME instances may be
mirrored, scaled, or rotated by CHAnge command, but may not be sheared
(:Z) or aspected (:Y).  If you need to shear or aspect a geometry, you
must encapsulated it in a permanently named instance, which may not be
subsequently smashed. 

The GROUP command is identical to WRAp in function except that
components are selected individually instead of by region. 

.SS OPTIONS
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text. 
If omitted, any component type may be selected.
.TP
.I <layer>
Limit selection to layer number, "0" or omitted designates all layers.
.TP
.I <devicename>
The name to be used for the new wrapped instance.  If omitted, an
internally generated name of the form "NONAME_<number>" will be used.
.TP 
.I <xyorig>
The point which will become the 0,0 coordinate in the new instance.
.TP 
.I <xy1> <xy2>
The bounding box used to select components to be wrapped.
}

#N: CALibrate
#D: Calibrate the display to match a digitizing tablet
#S: unimplemented

#N: CMAp
#D: Modify the color map
#S: unimplemented

#N: DEClare
#D: Declare a stretch point in a cell
#S: unimplemented

N: MEMory
D: Print remaining memory
S: unimplemented

N: TIMe
D: Print the current and elapsed time to the console
S: complete
U: TIM
T: {
Prints the current 24-hour time to the console in the format:
"Hour:Minutes:Seconds".  If TIMe had been called previously,
the elapsed time will also be printed.

For example:
.nf
    MAIN> time
        07/29/2006 19:11:14
    MAIN> time
	07/29/2006 19:11:18, elapsed since last call: 4 seconds
.fi

TIMe can be useful in scripts for benchmarking internal Piglet operations.
}

#N: XASsign
#D: Assign Stretch points to a cell
#S: unimplemented

#N: YASsign
#D: Assign Stretch points to a cell
#S: unimplemented

#N: ZAP
#D: Delete components with zero extent
#S: unimplemented


